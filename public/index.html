<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <link rel="icon" type="image/gif" href="%PUBLIC_URL%/2.gif" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="‰∏ªÈ°µÁΩëÁ´ôÁÆÄ‰ªã WangYi!" />
  <meta property="og:site_name" content="WangYi Profile Page">
  <meta property="og:image" content="https://media.discordapp.net/attachments/1392004981829140492/1407226678664757328/image.png?ex=68a55579&is=68a403f9&hm=61abfc5512d252ed054f899cc4a08e9482d618a03e857eb7e77d81b926a8dc6b&=&format=webp&quality=lossless&width=704&height=545">
  <meta property="og:title" content="WangYi Profile Page">
  <meta property="og:description" content="How Can I Get You If I'm Normal?on" />
  <meta property="og:url" content="https://wang-yi-lumi21.vercel.app/">
  <title>WangYi</title>
</head>
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>

  <!-- Audio elements for preloading -->
  <audio id="background-music" preload="auto" crossorigin="anonymous">
    Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ th·∫ª audio.
  </audio>
  <audio id="preload-audio" preload="auto" crossorigin="anonymous" style="display:none;"></audio>

  <script>
    const audio = document.getElementById('background-music');
    const preloadAudio = document.getElementById('preload-audio');
    audio.volume = 0.3;
    preloadAudio.volume = 0.3;
    
    // Danh s√°ch nh·∫°c v·ªõi th√¥ng tin chi ti·∫øt
    const musicTracks = [
      { 
        src: "music/SYENSAN.mp3", 
        name: "SYENSAN",
        loaded: false,
        duration: null
      },
      { 
        src: "music/NormalNoMore.mp3", 
        name: "Normal No More",
        loaded: false,
        duration: null
      }
    ];
    
    // Cache audio buffers
    const audioCache = new Map();
    let preloadQueue = [...musicTracks];
    
    let currentTrackIndex = 0;
    let nextTrackIndex = 1;
    let audioInitialized = false;
    let userHasInteracted = false;
    let isPlaying = false;
    let playPromise = null;
    let autoplayAttempted = false;
    let isLoading = false;

    // Preload v√† cache audio
    const preloadTrack = async (trackIndex) => {
      const track = musicTracks[trackIndex];
      if (track.loaded || audioCache.has(track.src)) return true;
      
      return new Promise((resolve) => {
        console.log('‚¨áÔ∏è Preloading:', track.name);
        const tempAudio = new Audio();
        
        tempAudio.addEventListener('canplaythrough', () => {
          track.loaded = true;
          track.duration = tempAudio.duration;
          audioCache.set(track.src, tempAudio);
          console.log('‚úÖ Loaded:', track.name, `(${Math.round(track.duration)}s)`);
          resolve(true);
        });
        
        tempAudio.addEventListener('error', () => {
          console.log('‚ùå Failed to load:', track.name);
          resolve(false);
        });
        
        // Timeout after 10 seconds
        setTimeout(() => {
          console.log('‚è±Ô∏è Timeout loading:', track.name);
          resolve(false);
        }, 10000);
        
        tempAudio.preload = 'auto';
        tempAudio.src = track.src;
        tempAudio.load();
      });
    };

    // Preload batch tracks
    const preloadBatch = async () => {
      const loadPromises = musicTracks.map((_, index) => preloadTrack(index));
      await Promise.allSettled(loadPromises);
      console.log('üéµ All tracks preload completed');
    };

    // H√†m ch·ªçn b√†i h√°t ng·∫´u nhi√™n v·ªõi preload
    const selectRandomTrack = async () => {
      const availableTracks = musicTracks
        .map((track, index) => ({ track, index }))
        .filter(({ track }) => track.loaded || audioCache.has(track.src));
      
      if (availableTracks.length === 0) {
        // Fallback: ch·ªçn track ƒë·∫ßu ti√™n v√† c·ªë g·∫Øng load
        currentTrackIndex = 0;
        await preloadTrack(0);
      } else {
        const randomIndex = Math.floor(Math.random() * availableTracks.length);
        currentTrackIndex = availableTracks[randomIndex].index;
      }
      
      const track = musicTracks[currentTrackIndex];
      
      // S·ª≠ d·ª•ng cached audio n·∫øu c√≥
      if (audioCache.has(track.src)) {
        const cachedAudio = audioCache.get(track.src);
        audio.src = cachedAudio.src;
      } else {
        audio.src = track.src;
      }
      
      // Preload b√†i ti·∫øp theo
      nextTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
      preloadTrack(nextTrackIndex);
      
      console.log('üéµ Selected:', track.name);
      return track;
    };

    // H√†m play an to√†n v·ªõi loading indicator
    const safePlay = async () => {
      try {
        isLoading = true;
        
        // Ch·ªù promise play tr∆∞·ªõc ƒë√≥ ho√†n th√†nh
        if (playPromise) {
          await playPromise.catch(() => {});
        }
        
        // ƒê·∫£m b·∫£o audio s·∫µn s√†ng
        if (audio.readyState < 3) { // HAVE_FUTURE_DATA
          console.log('‚è≥ Waiting for audio to load...');
          await new Promise((resolve) => {
            const onCanPlay = () => {
              audio.removeEventListener('canplay', onCanPlay);
              audio.removeEventListener('canplaythrough', onCanPlay);
              resolve();
            };
            audio.addEventListener('canplay', onCanPlay);
            audio.addEventListener('canplaythrough', onCanPlay);
            
            // Timeout after 5 seconds
            setTimeout(() => {
              audio.removeEventListener('canplay', onCanPlay);
              audio.removeEventListener('canplaythrough', onCanPlay);
              resolve();
            }, 5000);
          });
        }
        
        if (audio.paused) {
          playPromise = audio.play();
          await playPromise;
          isPlaying = true;
          isLoading = false;
          console.log('‚úÖ Audio playing:', musicTracks[currentTrackIndex].name);
          return true;
        }
        
        isLoading = false;
        return true;
      } catch (error) {
        isPlaying = false;
        isLoading = false;
        playPromise = null;
        
        if (error.name === 'NotAllowedError') {
          if (!userHasInteracted && !autoplayAttempted) {
            console.log('üîá Autoplay blocked - waiting for user interaction');
            autoplayAttempted = true;
          }
          return false;
        } else if (error.name !== 'AbortError') {
          console.log('‚ùå Play failed:', error.name);
        }
        return false;
      }
    };

    // H√†m pause an to√†n
    const safePause = async () => {
      try {
        if (playPromise) {
          await playPromise.catch(() => {});
        }
        
        if (!audio.paused) {
          audio.pause();
          isPlaying = false;
        }
      } catch (error) {
        // Ignore pause errors
      }
    };

    // H√†m ph√°t b√†i ti·∫øp theo v·ªõi instant switching
    const playNextTrack = async () => {
      if (!audioInitialized) return;
      
      console.log('‚è≠Ô∏è Switching to next track...');
      await safePause();
      
      // Instant switch v·ªõi preloaded track
      await selectRandomTrack();
      
      // Immediate play without delay
      await safePlay();
    };

    // Kh·ªüi t·∫°o audio khi c√≥ t∆∞∆°ng t√°c
    const initializeAudio = async () => {
      if (audioInitialized) return true;
      
      userHasInteracted = true;
      console.log('üé∂ Initializing audio system...');
      
      // Ch·ªçn track ƒë√£ ƒë∆∞·ª£c preload
      await selectRandomTrack();
      
      const success = await safePlay();
      if (success) {
        audioInitialized = true;
        console.log('üéâ Audio system ready!');
        removeInteractionListeners();
        
        // Ti·∫øp t·ª•c preload c√°c track c√≤n l·∫°i
        preloadBatch();
        return true;
      }
      return false;
    };

    // X·ª≠ l√Ω t∆∞∆°ng t√°c ng∆∞·ªùi d√πng - t·ªëi ∆∞u cho mobile
    let interactionHandled = false;
    let interactionAttempts = 0;
    const MAX_INTERACTION_ATTEMPTS = 3;
    
    const handleUserInteraction = async (e) => {
      if (interactionHandled || audioInitialized) return;
      
      // ƒê·∫∑c bi·ªát x·ª≠ l√Ω cho mobile - ƒë·∫£m b·∫£o l√† t∆∞∆°ng t√°c th·ª±c s·ª±
      if (e.type === 'touchmove' && !e.touches) return;
      if (e.type === 'scroll' && !userHasInteracted) return; // Skip passive scroll
      
      interactionAttempts++;
      console.log('üëÜ User interaction detected:', e.type, `(attempt ${interactionAttempts})`);
      
      // ƒê·ªëi v·ªõi mobile, ƒë·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o t∆∞∆°ng t√°c ho√†n th√†nh
      if (e.type.startsWith('touch')) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      interactionHandled = true;
      const success = await initializeAudio();
      
      if (!success && interactionAttempts < MAX_INTERACTION_ATTEMPTS) {
        // Reset ƒë·ªÉ th·ª≠ l·∫°i v·ªõi t∆∞∆°ng t√°c m·∫°nh h∆°n
        interactionHandled = false;
        console.log('üîÑ Retrying audio initialization...');
        
        // ƒê·ª£i 1 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i
        setTimeout(() => {
          if (!audioInitialized) {
            interactionHandled = false;
          }
        }, 1000);
      }
    };

    // Th√™m event listeners cho t∆∞∆°ng t√°c (t·ªëi ∆∞u cho mobile)
    const interactionEvents = [
      'click', 'touchstart', 'touchend', 'touchmove',
      'keydown', 'scroll', 'mousemove', 'mousedown',
      'pointerdown', 'pointerup', 'gesturestart'
    ];
    
    const addInteractionListeners = () => {
      interactionEvents.forEach(evt => {
        document.addEventListener(evt, handleUserInteraction, { 
          once: false,
          passive: true,
          capture: true 
        });
      });
      
      // Th√™m listener cho window ƒë·ªÉ b·∫Øt m·ªçi t∆∞∆°ng t√°c
      window.addEventListener('focus', handleUserInteraction, { passive: true });
      window.addEventListener('touchstart', handleUserInteraction, { passive: true });
    };

    const removeInteractionListeners = () => {
      interactionEvents.forEach(evt => {
        document.removeEventListener(evt, handleUserInteraction, true);
      });
      window.removeEventListener('focus', handleUserInteraction);
      window.removeEventListener('touchstart', handleUserInteraction);
    };

    // Th·ª≠ autoplay v·ªõi preloaded track
    const attemptAutoplay = async () => {
      // B·∫Øt ƒë·∫ßu preload ngay l·∫≠p t·ª©c
      const preloadPromise = preloadTrack(0);
      
      await selectRandomTrack();
      const success = await safePlay();
      
      if (success) {
        audioInitialized = true;
        console.log('üöÄ Autoplay successful!');
        
        // Continue preloading trong background
        preloadBatch();
      } else {
        // N·∫øu autoplay th·∫•t b·∫°i, v·∫´n preload ƒë·ªÉ s·∫µn s√†ng
        console.log('‚è≥ Waiting for user interaction...');
        preloadPromise.then(() => {
          addInteractionListeners();
        });
      }
    };

    // X·ª≠ l√Ω visibility change - c·∫£i thi·ªán cho mobile
    let visibilityTimeout;
    const handleVisibilityChange = () => {
      if (!audioInitialized) return;
      
      clearTimeout(visibilityTimeout);
      visibilityTimeout = setTimeout(async () => {
        if (document.hidden || document.visibilityState === 'hidden') {
          if (isPlaying) {
            await safePause();
            console.log('‚è∏Ô∏è Paused (app backgrounded)');
          }
        } else if (document.visibilityState === 'visible' && userHasInteracted && !isPlaying) {
          // ƒê·ªëi v·ªõi mobile, ƒë·ª£i th√™m ch√∫t ƒë·ªÉ app ho√†n to√†n active
          setTimeout(async () => {
            const success = await safePlay();
            if (success) {
              console.log('‚ñ∂Ô∏è Resumed (app foregrounded)');
            }
          }, 200);
        }
      }, 150); // TƒÉng delay cho mobile
    };

    // Th√™m x·ª≠ l√Ω cho mobile app lifecycle
    const handlePageShow = () => {
      console.log('üì± Page show event');
      if (audioInitialized && userHasInteracted && !isPlaying) {
        setTimeout(async () => {
          await safePlay();
        }, 300);
      }
    };

    const handlePageHide = () => {
      console.log('üì± Page hide event');
      if (isPlaying) {
        safePause();
      }
    };

    // Event listeners cho audio v·ªõi enhanced feedback
    audio.addEventListener('ended', playNextTrack);
    
    audio.addEventListener('loadstart', () => {
      isLoading = true;
      console.log('‚¨áÔ∏è Loading:', musicTracks[currentTrackIndex]?.name || 'Unknown');
    });
    
    audio.addEventListener('loadeddata', () => {
      console.log('üìä Data loaded');
    });
    
    audio.addEventListener('canplay', () => {
      isLoading = false;
      console.log('‚ñ∂Ô∏è Ready to play');
    });
    
    audio.addEventListener('playing', () => {
      isPlaying = true;
      isLoading = false;
      const track = musicTracks[currentTrackIndex];
      console.log(`üéµ Now Playing: ${track.name} ${track.duration ? `(${Math.round(track.duration)}s)` : ''}`);
    });
    
    audio.addEventListener('pause', () => {
      isPlaying = false;
    });
    
    audio.addEventListener('waiting', () => {
      console.log('‚è≥ Buffering...');
    });
    
    audio.addEventListener('error', (e) => {
      isLoading = false;
      const errorMsg = e.target.error?.message || 'Unknown error';
      console.log('üí• Audio error:', errorMsg);
      
      // Auto retry with next track
      setTimeout(() => {
        console.log('üîÑ Auto-retrying with next track...');
        playNextTrack();
      }, 1000);
    });

    // Event listener cho visibility change v√† mobile events
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('pageshow', handlePageShow);
    window.addEventListener('pagehide', handlePageHide);
    
    // Mobile-specific events
    window.addEventListener('focus', handleVisibilityChange);
    window.addEventListener('blur', () => {
      if (isPlaying) safePause();
    });

    // Kh·ªüi t·∫°o khi DOM ready v·ªõi aggressive preloading
    const init = () => {
      console.log('üéº Initializing high-speed audio system...');
      
      // Detect device v√† connection
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const isSlowConnection = connection && (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g');
      
      console.log(`üì± Device: ${isMobile ? 'Mobile' : 'Desktop'}${isIOS ? ' (iOS)' : ''}`);
      if (connection) {
        console.log(`üåê Connection: ${connection.effectiveType} (${connection.downlink}Mbps)`);
      }
      
      // B·∫Øt ƒë·∫ßu preload ngay l·∫≠p t·ª©c n·∫øu connection t·ªët
      if (!isSlowConnection) {
        console.log('üöÄ Starting aggressive preload...');
        setTimeout(() => preloadBatch(), 50);
      } else {
        console.log('üêå Slow connection detected - conservative loading');
        setTimeout(() => preloadTrack(0), 100);
      }
      
      if (isIOS) {
        // iOS y√™u c·∫ßu t∆∞∆°ng t√°c m·∫°nh h∆°n
        console.log('üçé iOS detected - interaction required');
        setTimeout(() => {
          if (!audioInitialized) addInteractionListeners();
        }, 500);
      } else {
        // Th·ª≠ autoplay v·ªõi delay t·ªëi thi·ªÉu
        setTimeout(attemptAutoplay, isMobile ? 150 : 50);
      }
      
      // Fallback v·ªõi timeout ng·∫Øn h∆°n
      const fallbackTime = isMobile ? 1500 : 2000;
      setTimeout(() => {
        if (!audioInitialized && !autoplayAttempted) {
          console.log('üîî Tap anywhere to start music! üéµ');
          addInteractionListeners();
        }
      }, fallbackTime);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>